运输层协议只工作在端系统中，将来自应用进程的报文移动到网络层，反向也是运输层。中间路由器不识别任何运输层附加在报文上的信息

运输层提供的服务一定程度受制于网络层

### 运输层概述

UDP（用户数据报协议）、TCP（传输控制协议）。

网络层的IP（网际协议）尽可能传递来自运输层的报文段，但不作任何确保，所以是不可靠的。而运输层协议的基本责任是：将两个端系统间IP的交付服务扩展为运行在端系统上两个进程之间的交付服务。简单来说，从“主机交付”扩展为“进程交付”，其中主要依靠了运输层的多路复用与多路分解。

UDP：数据交付、报文段首部差错检查字段
TCP：上述、可靠数据传输、拥塞控制

### 多路复用与多路分解

对于一个目的主机，在接收到报文段后，要通过运输层交付到合适的应用层进程中（实际上是交给了套接字）。

多路分解：接收方运输层通过报文段中数个字段实现套接字定向，交付给应用层。
多路复用：发送方在主机的不同套接字收集数据块，为每个数据块封装首部信息形成报文段，交付给网络层

基础的报文段格式如下：源端口号（16bit）、目的端口号（16bit）
其中0˜ˋ1023是周知端口号，受到保留。运输层通过端口号配对套接字

#### UDP的多路复用与分解
通常服务端要指定特定端口，而客户端的运输层自动分配即可。

源端口号作为“返回地址”，当目的进程需要回发时取值。

UDP套接字是一个二元组标识的：目的IP地址、目的端口号，在检查套接字后，两个不同源但同目的的报文段会被接入同一个套接字进入同一个进程。

#### TCP的多路复用与分解
TCP套接字是四元组：源IP、源端口、目的IP、目的端口。检查套接字后，两个不同源的报文段绘本定向到两个不同的套接字，除非报文段中有“初始创建连接”的请求。在连接之后到达的、四元组相同的报文段会进入连接的进程。

事实上，现今Web服务器一般只使用一个进程，而是为每个TCP连接创建一个具有套接字的新“线程”。

非持续HTTP会导致TCP连接的反复创建关闭影响Web服务器性能


### UDP的运输

DNS是一个通常使用UDP协议的应用层例子。DNS应用想要进行查询时，会构造一个查询报文交给UDP。

UDP的优点：
1. 发送控制：由于TCP有拥塞控制机制，有时不能满足实时应用的最小发送速率。此外，虽然UDP缺少完备的报文段交付服务，但部分可以在应用内部中实现，例如可靠性
2. 无须连接：不会有连接时延、不需要维护连接状态以及相关参数
3. 分组首部开销小：TCP首部有20个字节，UDP只有8字节

![[Pasted image 20241217171157.png]]

问题：
UDP中缺乏拥塞控制会导致发送方与接收方之间基于路由器分组溢出导致的高丢包率，同时容易挤压TCP会话

#### UDP报文段结构

除了先前提到的源端口号、目的端口号，还有16bit的长度（首部加数据）、16bit的校验和（便于接收方检查报文段是否正确）、数据

##### 校验和

发送方UDP：对报文段中所有16bit字的求和，任何溢出会被回卷（加到最低位），然后进行反码运算，最终计算结果就是校验和

接收方UDP：对报文段+校验和进行加法运算，结果应该全为1

在链路层的差错检测不生效、报文段存储在路由器内存时，都可能会发生比特差错，UDP的运输层端对端检测就是有必要的。

对于出错的报文段，UDP会丢弃或者给出警告

### 可靠数据传输原理
可靠性问题在应用层、运输层、链路层都可能出现。

数据经过不可靠信道后依然正确是TCP的责任

以下只考虑单向，全双工大相径庭。

#### 构造可靠数据传输协议（状态机FSM见互联网）

##### rdt1.0（经完全可靠的信道）

发送方将数据分组，接收方按顺序接收不提供任何反馈信息。

##### rdt2.0（经具有比特差错的信道）

分组传输、传播、缓存的过程中比特受损，但目前依然假设分组顺序不发生改变。

此时接收方将具有控制响应报文：肯定确认ACK、否定确认NAK。使得发送方知晓内容发送情况。对于有问题的分组，发送方将会进行重传，称为：ARQ协议（自动重传请求协议）

rdt2.0属于停等协议

ARQ协议本质上通过以下功能辅助处理：
1. 差错检测：通过首部等额外的字节跟随分组发送
2. 接收方反馈：ACK与NAK报文（只需要1bit），发送方此时进入等待
3. 重传：有差错的分组进行重传

缺陷：未考虑ACK、NAK分组是否受损
解决方法：在对数据分组时添加序号字段，通过当前分组序号是否出现过来判断重传（通过1bit与2模运算即可）

rdt2.1增加了状态（详情见互联网），rdt2.2在前者基础上，去掉NAK报文、接收方在得到重传包后重新发送ACK表示收到

##### rdt3.0（经具有比特差错的丢包信道）

除了比特受损外，信道还可能丢包。当发送方传输的分组丢失、或者接收方对该分组的ACK发送了丢失，此时都视作丢包并进行重传。

发送方一般会等待：一个往返时延＋接收方处理一个分组的时间

冗余数据分组：未丢包但发送方误以为丢包而重传（rdt2.2已解决）

倒计数定时器：在给定时间量过期后，中断发送方。

由此发送方可以做到：发送分组后启动定时器->响应定时器中断（做出重传等操作）->终止定时器

rdt3.0也称为比特交替协议
![[Screenshot_2024-12-18-08-00-25-416_md.obsidian.png]]

#### 流水线可靠数据传输协议
相较于rdt的停等操作（收到响应后传输下一个）会导致浪费大量链路吞吐量，流水线（发完一个后接着发下一个，无需等待确认）可以提高性能。

流水线要求可靠数据传输协议：
1. 增加序号范围
2. 发送方和接收方需要缓存多个分组，例如发送方需要缓存未确认的分组
3. 解决差错恢复：GBN（回退N步）、SR（选择重传）

##### GBN 回退N步
流水线中的分组受到值N的限制
![[Screenshot_2024-12-18-08-47-07-666_md.obsidian.png]]
随着协议运行，窗口N会向右移动，GBN也叫滑动窗口协议。流量控制是N存在的原因之一。

按分组标明序号的kbit在运算时使用模2ˆk运算

GBN发送方必须响应的三种类型的事件：
1. 上层调用：检查窗口是否未满并告诉上层
2. 接收ACK：对序号为n的分组采取累积确认（表明接收方接收到了n以及之前的所有分组）
3. 超时事件：使用定时器恢复数据或者确认分组丢失，超时将重传所有已发送但未确认的分组

GBN接收方：
如果按序接收到了n个分组，则为n分组发送一个ACK，并将数据交付到上层。其他任何情况下都会丢弃该分组，为最近的一个正确分组发送ACK（每次交付一个分组）
丢弃所有失序分组，接收方必须按序交付数据。假设n未到达而已经接收到了n＋1，则可能可以进行缓存；如果n以及n＋1等发生重传，那么丢弃原有的n＋1。理论上，直接丢弃是更好的选择

下图是窗口为4的GBN运行情况：
![[Screenshot_2024-12-18-09-29-28-369_md.obsidian.png]]

##### SR 选择重传

GBN存在一些问题：当N和带宽时延都很大时，流水线中单个分组出现差错就会导致大量分组重传。

SR协议通过让发送方仅重传它认为的可能出错的分组，这就要求接收方逐个确认正确接收的分组。接收方将确认一个正确接收的分组，如果失序则缓存至所有序号更小的丢失分组（要重新确认这些分组）都被接收，然后将这一批分组按序交付
![[Screenshot_2024-12-18-11-35-40-093_md.obsidian.png]]

对SR协议来说，发送方和接收方的滑动窗口并不总是一致。当窗口较大，序号范围较小时，不同步会导致：接收方无法区分该序号是上次的重传还是下次的初始传输。

窗口长度必须小于等于序号空间的一半。

### TCP的传输

TCP基于上述可靠数据传输的基本原理

#### TCP连接

该连接的共同状态只保留在两个端系统的TCP程序中，并不像FDM、TDM一样进入电路。路由器对TCP的连接视而不见。

TCP提供的是全双工服务（即双向流通）、点对点的，所谓多播是不可能的。

三次握手：发起连接的客户进程通过运输层向服务器进程发送报文1，服务器进程使用报文2进行响应，最后客户进程用报文3建立握手（报文3中可以承载有效载荷）

发送数据：在数据进入套接字后，便受到TCP程序控制，数据首先进入连接的发送缓存里，该缓存空间是握手时建立的。接着便是取出数据块、投递到网络层，该数据块的大小受限于不含首部的最大报文段长度MSS（一般取决于最大链路层帧长度MTU）。由于以太网和PPP链路层协议都有1500bytes的MTU，所以MSS一般取1460bytes。每个数据块配上TCP首部后成为报文段传给网络层。
网络层将报文段封装在IP数据报中并发送。当另一端的TCP接收后，该数据块会被放入接收缓存，在应用读取时穿过套接字

#### TCP报文段结构
