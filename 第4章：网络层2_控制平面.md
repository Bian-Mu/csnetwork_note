
转发表（流表）是链接数据平面和控制平面的主要元素。上一章通过使用转发表，进行转发；本章节将理解转发表是如何计算、维护、安装的。

总的来说，主要有两种可能的方法（与数据平面一样）：      
![](Screenshot_2024-12-25-08-17-39-326_com.flyersoft.moonreaderp.png)
1. 每台路由器控制：在路由器中运行路由选择算法，由路由器内部的路由选择组件与其他车路由器通信，以计算其转发表的值。例如OSPF、BGP都是该方式
2. 逻辑集中式控制：有中央控制器计算并分发转发表以供每台路由器使用。该控制器通过某协议与路由器中的CA（控制代理）交互，来管理转发表。CA通常只有少量功能，且是被动工作的。SDN一般会采用该方式

### 路由选择算法

根本目的是确认一条从发送方到接收方的路径（开销尽可能小）。  

可以将路由器与链路抽象成图G=(N, E)，具有N个节点和E条边。  
![](Screenshot_2024-12-25-08-51-03-604_md.obsidian.png)
用c(x, y)表示从x节点到y节点的开销，x与y互为邻居。开销可以反映出链路的物理长度、链路传输速率等信息。

路由算法的目标就是找出两个节点之间的最低开销路径，同开销时选择最短路径。

算法主要有三种分类方式：
1. 集中式路由选择算法：先获取所有节点的连通性与链路的开销，再计算。依靠全局状态信息的算法称作LS（链路状态）算法
2. 分散式路由选择算法：通过节点之间的信息迭代，层层计算出路径开销。DV（距离向量）算法
或者：  
1. 静态路由选择算法
2. 动态路由选择算法
再或者：  
1. 负载敏感算法：链路开销会动态变化来反映拥塞
2. 负载迟钝算法

#### 集中/分散

以下两个算法没有明显的赢家。
##### LS算法（集中）
每个节点向网络中其他节点广播链路状态分组，从而传递拓扑与链路开销。这通常由链路状态广播算法完成。

广播完成后，每个节点都具有完整的拓扑图，可以单独运行LS算法并得到集合。

以属于LS算法的Dijkstra算法为例，计算从节点u开始的，到达其他所有节点的最低开销路径。  

当LS算法终止时，通过路径上节点的迭代回溯，可以构建出从源节点到目的节点的完整路径，从而得到转发表  
![](b4fe9a36d11104473f568c1d42423cd2.png)

当链路开销等于链路负载时，可能会有如下振荡产生：  
![](9bcaaa0a0c7622084b486b934e029763.png)
假设xyz节点分别要向w节点发送1、e、1大小的流量，链路上的开销为承载的负载。  
第二次运行LS算法时，yx先后改变路径，导致链路负载又发生变化；   
第三次时，zyx又先后改变路径。  

由此，LS算法每次结果都不同（事实上在拥塞、时延测试中也受到该问题困扰）。为了解决振荡，可以确保并非所有路由器都同时运行LS算法。但是路由器会自同步。为了避免自同步，可以让发送链路通告的时机随机化

##### DV算法（分散）

DV算法是一种迭代、异步的算法，每个节点都需要依靠邻居获取信息。交换信息的过程会持续到邻居之间都计算完毕。

假设dx(y)是x到y的最小开销，则根据Bellman-Ford方程，dx(y)=min(v){c(x, v)+dv(y)}（v是x可能的邻居）。依据该方程，可以知晓我们所求的最短路径必然会经过节点min(v)。

借用这一结论，节点x只需要维护以下信息：   
1. 对于每个邻居v，维护c(x, v)
2. 节点x的距离向量Dx，包含x到达每个目的地y的开销计算值
3. 每个邻居v的距离向量Dv

在DV算法中，每个节点w不时地向邻居发送自己的距离向量Dw副本；  
当节点x收到邻居的Dw副本时，会根据Bellman-Ford方程更新自己的距离向量Dx。一旦Dx发生更新，则会直接向邻居发送更新后的Dx，继而影响所有的邻居，最终转发表中的开销收敛到dx(y)。  

这种分布式更新在链路开销变化时可能陷入环路。![](d27d78d25c08cb9c888a92ea951fe06f.png)
- 开销减小：左图c(x, y)从4减小到1，假设y最先发现开销变化并开始DV算法以及更新，2次迭代后便可以回归静止
- 开销增加：从4增加到60，Dy(x)=min{c(y, x)+Dx(x), c(y, z)+Dz(x)}=6，这显然是错误的，发生了路由选择环路。该DV算法将在44次迭代以至于z计算出途径y的路径的开销大于50为止。

以上状况可以通过“毒性逆转”方式避免。主要思想为：如果z通过y到达x，则z需要通告y，z直接去往x的开销被标记为无限大。只要z一直通过y到达x，则这个谎言不会被结束，因此导致y永远不会尝试从z到达x。

借助“毒性逆转”，上图中，y在发现开销增加后，依然选择直接走x，不经过z。此时z自己发现直接去x的开销更小因此改变路径。因为路径不再经过y,所以z不再撒谎，对y通告Dz(x)=50，收到真话后，y重新计算更新Dy(x)，选择经过z，y开始对z撒谎（即标记y直达x的开销为无限大）

