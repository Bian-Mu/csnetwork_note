运输层协议只工作在端系统中，将来自应用进程的报文移动到网络层，反向也是运输层。中间路由器不识别任何运输层附加在报文上的信息

运输层提供的服务一定程度受制于网络层

### 运输层概述

UDP（用户数据报协议）、TCP（传输控制协议）。

网络层的IP（网际协议）尽可能传递来自运输层的报文段，但不作任何确保，所以是不可靠的。而运输层协议的基本责任是：将两个端系统间IP的交付服务扩展为运行在端系统上两个进程之间的交付服务。简单来说，从“主机交付”扩展为“进程交付”，其中主要依靠了运输层的多路复用与多路分解。

UDP：数据交付、报文段首部差错检查字段
TCP：上述、可靠数据传输、拥塞控制

### 多路复用与多路分解

对于一个目的主机，在接收到报文段后，要通过运输层交付到合适的应用层进程中（实际上是交给了套接字）。

多路分解：接收方运输层通过报文段中数个字段实现套接字定向，交付给应用层。
多路复用：发送方在主机的不同套接字收集数据块，为每个数据块封装首部信息形成报文段，交付给网络层

基础的报文段格式如下：源端口号（16bit）、目的端口号（16bit）
其中0˜ˋ1023是周知端口号，受到保留。运输层通过端口号配对套接字

#### UDP的多路复用与分解
通常服务端要指定特定端口，而客户端的运输层自动分配即可。

源端口号作为“返回地址”，当目的进程需要回发时取值。

UDP套接字是一个二元组标识的：目的IP地址、目的端口号，在检查套接字后，两个不同源但同目的的报文段会被接入同一个套接字进入同一个进程。

#### TCP的多路复用与分解
TCP套接字是四元组：源IP、源端口、目的IP、目的端口。检查套接字后，两个不同源的报文段绘本定向到两个不同的套接字，除非报文段中有“初始创建连接”的请求。在连接之后到达的、四元组相同的报文段会进入连接的进程。

事实上，现今Web服务器一般只使用一个进程，而是为每个TCP连接创建一个具有套接字的新“线程”。

非持续HTTP会导致TCP连接的反复创建关闭影响Web服务器性能


### UDP的运输

DNS是一个通常使用UDP协议的应用层例子。DNS应用想要进行查询时，会构造一个查询报文交给UDP。

UDP的优点：
1. 发送控制：由于TCP有拥塞控制机制，有时不能满足实时应用的最小发送速率。此外，虽然UDP缺少完备的报文段交付服务，但部分可以在应用内部中实现，例如可靠性
2. 无须连接：不会有连接时延、不需要维护连接状态以及相关参数
3. 分组首部开销小：TCP首部有20个字节，UDP只有8字节

![[Pasted image 20241217171157.png]]

问题：
UDP中缺乏拥塞控制会导致发送方与接收方之间基于路由器分组溢出导致的高丢包率，同时容易挤压TCP会话

#### UDP报文段结构

除了先前提到的源端口号、目的端口号，还有16bit的长度（首部加数据）、16bit的校验和（便于接收方检查报文段是否正确）、数据
![[34e41ec2737385992bca89c1867b7331.png]]
##### 校验和

发送方UDP：对报文段中所有16bit字的求和，任何溢出会被回卷（加到最低位），然后进行反码运算，最终计算结果就是校验和

接收方UDP：对报文段+校验和进行加法运算，结果应该全为1

在链路层的差错检测不生效、报文段存储在路由器内存时，都可能会发生比特差错，UDP的运输层端对端检测就是有必要的。

对于出错的报文段，UDP会丢弃或者给出警告

### 可靠数据传输原理
可靠性问题在应用层、运输层、链路层都可能出现。

数据经过不可靠信道后依然正确是TCP的责任

以下只考虑单向，全双工大相径庭。

#### 构造可靠数据传输协议（状态机FSM见互联网）

##### rdt1.0（经完全可靠的信道）

发送方将数据分组，接收方按顺序接收不提供任何反馈信息。

##### rdt2.0（经具有比特差错的信道）

分组传输、传播、缓存的过程中比特受损，但目前依然假设分组顺序不发生改变。

此时接收方将具有控制响应报文：肯定确认ACK、否定确认NAK。使得发送方知晓内容发送情况。对于有问题的分组，发送方将会进行重传，称为：ARQ协议（自动重传请求协议）

rdt2.0属于停等协议

ARQ协议本质上通过以下功能辅助处理：
1. 差错检测：通过首部等额外的字节跟随分组发送
2. 接收方反馈：ACK与NAK报文（只需要1bit），发送方此时进入等待
3. 重传：有差错的分组进行重传

缺陷：未考虑ACK、NAK分组是否受损
解决方法：在对数据分组时添加序号字段，通过当前分组序号是否出现过来判断重传（通过1bit与2模运算即可）

rdt2.1增加了状态（详情见互联网），rdt2.2在前者基础上，去掉NAK报文、接收方在得到重传包后重新发送ACK表示收到

##### rdt3.0（经具有比特差错的丢包信道）

除了比特受损外，信道还可能丢包。当发送方传输的分组丢失、或者接收方对该分组的ACK发送了丢失，此时都视作丢包并进行重传。

发送方一般会等待：一个往返时延+接收方处理一个分组的时间

冗余数据分组：未丢包但发送方误以为丢包而重传（rdt2.2已解决）

倒计数定时器：在给定时间量过期后，中断发送方。

由此发送方可以做到：发送分组后启动定时器->响应定时器中断（做出重传等操作）->终止定时器

rdt3.0也称为比特交替协议
![[Screenshot_2024-12-18-08-00-25-416_md.obsidian.png]]

#### 流水线可靠数据传输协议
相较于rdt的停等操作（收到响应后传输下一个）会导致浪费大量链路吞吐量，流水线（发完一个后接着发下一个，无需等待确认）可以提高性能。

流水线要求可靠数据传输协议：
1. 增加序号范围
2. 发送方和接收方需要缓存多个分组，例如发送方需要缓存未确认的分组
3. 解决差错恢复：GBN（回退N步）、SR（选择重传）

##### GBN 回退N步
流水线中的分组受到值N的限制
![[Screenshot_2024-12-18-08-47-07-666_md.obsidian.png]]
随着协议运行，窗口N会向右移动，GBN也叫滑动窗口协议。流量控制是N存在的原因之一。

按分组标明序号的kbit在运算时使用模2ˆk运算

GBN发送方必须响应的三种类型的事件：
1. 上层调用：检查窗口是否未满并告诉上层
2. 接收ACK：对序号为n的分组采取累积确认（表明接收方接收到了n以及之前的所有分组）
3. 超时事件：使用定时器恢复数据或者确认分组丢失，超时将重传所有已发送但未确认的分组

GBN接收方：
如果按序接收到了n个分组，则为n分组发送一个ACK，并将数据交付到上层。其他任何情况下都会丢弃该分组，为最近的一个正确分组发送ACK（每次交付一个分组）
丢弃所有失序分组，接收方必须按序交付数据。假设n未到达而已经接收到了n+1，则可能可以进行缓存；如果n以及n+1等发生重传，那么丢弃原有的n+1。理论上，直接丢弃是更好的选择

下图是窗口为4的GBN运行情况：
![[Screenshot_2024-12-18-09-29-28-369_md.obsidian.png]]

##### SR 选择重传

GBN存在一些问题：当N和带宽时延都很大时，流水线中单个分组出现差错就会导致大量分组重传。

SR协议通过让发送方仅重传它认为的可能出错的分组，这就要求接收方逐个确认正确接收的分组。接收方将确认一个正确接收的分组，如果失序则缓存至所有序号更小的丢失分组（要重新确认这些分组）都被接收，然后将这一批分组按序交付
![[Screenshot_2024-12-18-11-35-40-093_md.obsidian.png]]

对SR协议来说，发送方和接收方的滑动窗口并不总是一致。当窗口较大，序号范围较小时，不同步会导致：接收方无法区分该序号是上次的重传还是下次的初始传输。

窗口长度必须小于等于序号空间的一半。

### TCP的传输

TCP基于上述可靠数据传输的基本原理

#### TCP连接

该连接的共同状态只保留在两个端系统的TCP程序中，并不像FDM、TDM一样进入电路。路由器对TCP的连接视而不见。

TCP提供的是全双工服务（即双向流通）、点对点的，所谓多播是不可能的。

三次握手：发起连接的客户进程通过运输层向服务器进程发送报文1，服务器进程使用报文2进行响应，最后客户进程用报文3建立握手（报文3中可以承载有效载荷）

发送数据：在数据进入套接字后，便受到TCP程序控制，数据首先进入连接的发送缓存里，该缓存空间是握手时建立的。接着便是取出数据块、投递到网络层，该数据块的大小受限于不含首部的最大报文段长度MSS（一般取决于最大链路层帧长度MTU）。由于以太网和PPP链路层协议都有1500bytes的MTU，所以MSS一般取1460bytes。每个数据块配上TCP首部后成为报文段传给网络层。
网络层将报文段封装在IP数据报中并发送。当另一端的TCP接收后，该数据块会被放入接收缓存，在应用读取时穿过套接字

#### TCP报文段结构
![[e2838bcd4e6865c8e2b220bd0895727d.png]]
由于受到MSS的限制，TCP应用会将数据分成长度小于等于MSS的若干块

除了源端口号、目的端口号外，还有以下部分：
1. 检验和（UDP也有）
2. 32bit的序号：辅助可靠数据传输服务
3. 32bit的确认号（ACK）：辅助可靠数据传输服务
4. 16bit的接收窗口：用于流量控制，表示接收方愿意接收的字节数量
5. 4bit的首部长度：以32bit为单位的TCP首部长度（由于选项字段常常为空，所以一般TCP首部是20字节）
6. 可选与可变长的选项字段：用于发送方与接收方协商MSS大小、高速网络下作窗口调节因子
7. 6bit的标志字段（？怎么看都是8bit）：ACK指明ACK字段是否有效；RST、SYN、FIN用于连接的建立和拆除；CWR、ECE用于明确拥塞通告；URG指明存在紧急数据
8. 16bit的紧急数据指针：存在时，TCP将通知接收方的上层

##### 序号与确认号
TCP将数据视作无结构但有序的字节流。

报文段n的序号是n首个字节的字节流编号（TCP隐式的对数据的每一个字节编号）（编号不要求从0开始，原因自己查）

主机A向主机B发送数据时，也接收着B的报文段，因此主机A的确认号是主机B发过来的字节流编号的下一块。

TCP是累计确认的（即只确认流中第一个丢失字节的块）。

TCP对于失序报文段没有制定规则，交给TCP程序开发端选择，常见选择为：接收方立即丢弃；接收方将保留，等待缺少的字节来填补间隔。对于带宽而言后者更好

假设A、B分别从序号42、79开始
![[5e1e248c23ce3500176dc5a993e8f786.png]]

#### 往返时间的估计、往返超时

##### 估计往返时间
大多数TCP会在任意时刻只对一个不重传的报文段估计测量SampleRTT，由于路由器和端系统，SampleRTT会波动，因此会不断计算平均值：EstimateRTT＝(1－a)xERTT+axSRTT，一般a取0.125。用DevRTT估计SRTT与RTT的差距

##### 设置重传超时间隔
该事件间隔应该为ERTT+k，k受到SRTT的波动范围大小的影响，一般取ERTT+4xDRTT

#### 可靠数据传输
之前提到过，网络层的IP服务是不保证数据报正确交付的，因此TCP在IP上创建了可靠数据传输服务：确保一个进程从接收缓存中得到的是正确的数据流。（整个TCP只有一个定时器）

假设主机A对主机B发送一个大文件，此时A中的TCP应用会处理三个事件：
1. 将上层的数据块标号打包传输给网络层，此时如果定时器没有运行则启动
2. 定时器超时，则重传未应答的最小序号的报文段，然后重启定时器
3. 收到有效ACK后，如果ACK符合当前所需的序号，则累积确认；如果ACK大于当前序号，则表示接收方在确认数个未被确认的报文段，A要更新当前序号。如果当前有未被确认的报文段，则重启定时器

一些有趣的重传情况：
![[Screenshot_2024-12-19-11-12-39-715_com.flyersoft.moonreaderp.png]]
![[Screenshot_2024-12-19-11-12-52-181_com.flyersoft.moonreaderp.png]]

超时间隔加倍：实际情况中，每当发生重传时，发送方会将定时器超时间隔设置为2倍（呈指数型增长），这个值会在另外两个事件触发时恢复。CSMA/CD也是这个思路

冗余ACK：发送方已经收到该序号的ACK，再次收到了（例如B需要乱序丢包的包4，反复发送ACK4）

快速重传：当超时间隔过大时，重传分组的端到端时延变大，为了避免等待过久，发送方可以在定时器触发前注意到冗余ACK来知晓丢包。如果发送方连续收到3个相同的ACK，则无论是否超时，立刻重传报文段。

![[Screenshot_2024-12-19-11-33-46-340_md.obsidian.png]]

关于GBN和SR的选择：由于TCP是累积确认的，所以接收到的失序包不会被挨个确认，由此GBN不完全合适。一种方式是采用“选择确认”，允许接收方有选择的确认失序报文段，此时配合SR使用

#### TCP流量控制
先前讲过到达的数据块会被放到TCP接收缓存中，等待使用。因此缓存可能会溢出。

TCP流量控制服务是一个速度匹配服务，使得发送速率和接收方的应用读取速率相匹配。

便于理解，我们假设接收方会丢弃失序报文段。TCP要求发送方维护一个接收窗口的变量rwnd：接收方目前还有多少可用的缓存空间。主机B会将该值放在对应字段中告诉主机A。
此时会有一个新的问题：A收到rwnd＝0后不再发送报文，但此时B已经通过读取数据让rwnd>0了，但由于A不发送报文段导致B无法将该情况告知A。因此TCP规定，当rwnd＝0时，A要继续发送只有一个字节的报文段，B将非零rwnd的值放在该报文段的ACK中

#### TCP连接管理

假设主机A上的进程和主机B上的进程想要建立连接，则：
1. 客户端TCP向服务端TCP发送一个特殊的报文段SYN。SYN中不包含应用层数据，但在首部的SYN被置位。客户会随机选择初始序号并放置在SYN报文段的序号字段。报文段SYN同样会被IP数据报封装
2. 报文段SYN到达并被取出时，服务端将为连接分配缓存、变量，并发送“允许连接”的报文段SYNACK。SYNACK中SYN依然置位，ACK为客户端的随机初始序号+1，初始序号字段为服务端的随机序号
3. 客户端收到SYNACK后，将分配缓存和变量。客户端将发送一个报文段，其中SYN复位、ACK为服务端初始序号+1，该报文段将表示连接的正确建立（当前报文段可以塞应用层数据了）

连接建立完成后，之后的所有报文段的SYN始终为0。

TCP连接的双方都可以关闭连接。