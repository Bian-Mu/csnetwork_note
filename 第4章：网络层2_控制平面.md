
转发表（流表）是链接数据平面和控制平面的主要元素。上一章通过使用转发表，进行转发；本章节将理解转发表是如何计算、维护、安装的。

总的来说，主要有两种可能的方法（与数据平面一样）：      
![](Screenshot_2024-12-25-08-17-39-326_com.flyersoft.moonreaderp.png)
1. 每台路由器控制：在路由器中运行路由选择算法，由路由器内部的路由选择组件与其他车路由器通信，以计算其转发表的值。例如OSPF、BGP都是该方式
2. 逻辑集中式控制：有中央控制器计算并分发转发表以供每台路由器使用。该控制器通过某协议与路由器中的CA（控制代理）交互，来管理转发表。CA通常只有少量功能，且是被动工作的。SDN一般会采用该方式

### 路由选择算法

根本目的是确认一条从发送方到接收方的路径（开销尽可能小）。  

可以将路由器与链路抽象成图G=(N, E)，具有N个节点和E条边。  
![](Screenshot_2024-12-25-08-51-03-604_md.obsidian.png)
用c(x, y)表示从x节点到y节点的开销，x与y互为邻居。开销可以反映出链路的物理长度、链路传输速率等信息。

路由算法的目标就是找出两个节点之间的最低开销路径，同开销时选择最短路径。

算法主要有三种分类方式：
1. 集中式路由选择算法：先获取所有节点的连通性与链路的开销，再计算。依靠全局状态信息的算法称作LS（链路状态）算法
2. 分散式路由选择算法：通过节点之间的信息迭代，层层计算出路径开销。DV（距离向量）算法
或者：  
1. 静态路由选择算法
2. 动态路由选择算法
再或者：  
1. 负载敏感算法：链路开销会动态变化来反映拥塞
2. 负载迟钝算法

#### 集中/#分散

以下两个算法没有明显的赢家。
##### LS算法（集中）
每个节点向网络中其他节点广播链路状态分组，从而传递拓扑与链路开销。这通常由链路状态广播算法完成。

广播完成后，每个节点都具有完整的拓扑图，可以单独运行LS算法并得到集合。

以属于LS算法的Dijkstra算法为例，计算从节点u开始的，到达其他所有节点的最低开销路径。  

当LS算法终止时，通过路径上节点的迭代回溯，可以构建出从源节点到目的节点的完整路径，从而得到转发表  
![](b4fe9a36d11104473f568c1d42423cd2.png)

当链路开销等于链路负载时，可能会有如下振荡产生：  
![](9bcaaa0a0c7622084b486b934e029763.png)
假设xyz节点分别要向w节点发送1、e、1大小的流量，链路上的开销为承载的负载。  
第二次运行LS算法时，yx先后改变路径，导致链路负载又发生变化；   
第三次时，zyx又先后改变路径。  

由此，LS算法每次结果都不同（事实上在拥塞、时延测试中也受到该问题困扰）。为了解决振荡，可以确保并非所有路由器都同时运行LS算法。但是路由器会自同步。为了避免自同步，可以让发送链路通告的时机随机化

##### DV算法（分散）

DV算法是一种迭代、异步的算法，每个节点都需要依靠邻居获取信息。交换信息的过程会持续到邻居之间都计算完毕。

假设dx(y)是x到y的最小开销，则根据Bellman-Ford方程，dx(y)=min(v){c(x, v)+dv(y)}（v是x可能的邻居）。依据该方程，可以知晓我们所求的最短路径必然会经过节点min(v)。

借用这一结论，节点x只需要维护以下信息：   
1. 对于每个邻居v，维护c(x, v)
2. 节点x的距离向量Dx，包含x到达每个目的地y的开销计算值
3. 每个邻居v的距离向量Dv

在DV算法中，每个节点w不时地向邻居发送自己的距离向量Dw副本；  
当节点x收到邻居的Dw副本时，会根据Bellman-Ford方程更新自己的距离向量Dx。一旦Dx发生更新，则会直接向邻居发送更新后的Dx，继而影响所有的邻居，最终转发表中的开销收敛到dx(y)。  

这种分布式更新在链路开销变化时可能陷入环路。![](d27d78d25c08cb9c888a92ea951fe06f.png)
- 开销减小：左图c(x, y)从4减小到1，假设y最先发现开销变化并开始DV算法以及更新，2次迭代后便可以回归静止
- 开销增加：从4增加到60，Dy(x)=min{c(y, x)+Dx(x), c(y, z)+Dz(x)}=6，这显然是错误的，发生了路由选择环路。该DV算法将在44次迭代以至于z计算出途径y的路径的开销大于50为止。

以上状况可以通过“毒性逆转”方式避免。主要思想为：如果z通过y到达x，则z需要通告y，z直接去往x的开销被标记为无限大。只要z一直通过y到达x，则这个谎言不会被结束，因此导致y永远不会尝试从z到达x。

借助“毒性逆转”，上图中，y在发现开销增加后，依然选择直接走x，不经过z。此时z自己发现直接去x的开销更小因此改变路径。因为路径不再经过y,所以z不再撒谎，对y通告Dz(x)=50，收到真话后，y重新计算更新Dy(x)，选择经过z，y开始对z撒谎（即标记y直达x的开销为无限大）

### RIP（选路信息协议）

- 基于DV算法
- 最大接收15跳，超过视为距离无限，导致只能用于小型网络
- 每隔30s发送通告来更新DV，通告最多到达25个AS内的目的地的子网
- 如果超过180s没有收到通告，则视作该邻居死亡：
	- 通过该邻居的路径是小
	- 发送通告（邻居/广播）
	- 如果邻居的转发表变化，则邻居也会再发通告
	- 链接失败的信息会迅速迭代
- RIP运行在应用层
- 通告信息封装在UDP数据报中，周期性的发送
### OSPF（开放最短路优先）

之前的讨论都将网络视作执行同一算法的路由器集合，但实际上并不全面。现实网络的规模（DV算法迭代不了）、自治管理（内部算法的私密性），要求将路由器组织进AS（自治系统），每个AS由一组处于相同管理控制的路由器组成。

ISP根据网络大小，划分成数个AS，每个AS有全局唯一的标识ASN，由ICANN机构分配

在同一AS中的路由器运行相同的路由选择算法且有彼此的信息（参考DN11），此时算法称作“自治系统内部路由选择协议”

OSPF是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。

使用OSPF时，每台路由器以自己为根节点，确定一个覆盖整个子网的最短路径树。而各链路开销（实际上是权重）是由网络管理员配置的，可以都设置为1来实现最少跳数；也可以与链路容量成反比来避免流量使用低带宽链路。但要注意的是，OSPF不强制设置链路开销，只是提供机制

再次提醒，OSPF属于集中式，会向整个子网的路由器广播链路状态信息。即使未发生变化，也要周期性的广播。

OSPF通告包含在OSPF报文中，由IP直接承载，其对应上层协议字段的值为89。由于网络层只负责OSPF的报文，因此可靠传输、链路状态广播、链路是否运行（HELLO报文）、获得其他路由器的相关数据库等功能要靠OSPF自己实现。

##### OSPF的优点
1. 安全：能够鉴别OSPF路由器之间的交换。仅有受信任的路由器能参与AS内的OSPF协议。除此以外，OSPF可以设置无、简单、DM5等报文鉴别口令
2. 多条相同开销的路径：当有数条开销相同的路径时，OSPF允许分担流量而非单线传输
3. 单播、多播综合支持：MOSPF在原有基础上扩展，以此支持多播路由
4. 支持在单个AS中的层次结构：OSPF自治系统可以将整个网络分成多个区域，在每个区域中，存在边界路由器，它们负责流出区域的分组的路由选择。一个AS中只有一个主干区域，这一区域将为其他区域提供路由选择，该主干区域会包含所有的边界路由器。当有分组要穿过边界时，一定会经过边界路由器进入主干路由，再通过边界路由器进入新区域


### BGP（ISP之间的路由选择）

OSPF是一个AS内部路由选择协议。然而当分组要跨越多个AS时，我们需要一个AS间路由选择协议，该协议涉及多个AS的协调（因此AS通信必须用相同的AS间路由选择协议）。

所有的AS都使用BGP（边界网关协议），DN11也是。

BGP是分布式、异步的协议，粘合了多个ISP。

#### BGP的作用

假设存在一个AS，以及之中的一台路由器。当经过该路由器的分组的目的地仍然在AS中时，可以通过OSPF协议来计算转发表项。否则要使用BGP

在BGP中，分组不是路由到一个特定的目的地址，而是路由到CIDR化的前缀。转发表的表项具有如下格式：(x, I)，其中x是诸如172.16.68/22这样的前缀，I是路由器接口之一的接口号。

作为一种AS间的路由选择协议，BGP提供了以下功能：
1. 允许子网向因特网的其余部分通告自己的存在。
2. 当路由器有多条到达目的地路由器的路径时，通过第1点功能的辅助，确定最好的路由

#### 通告BGP路由信息

![](181d43a25bbe94b74dfe5af12e2cb296.png)
该网络具有3个AS，AS是一个具有前缀x的子网。  
图中的1c、2a、2c、3a是网关路由器，位于AS边缘，连接其他AS的路由器。  
假设要让所有路由器知晓AS3的前缀为x并且知道具体的路由路径，网络需要进行如下活动：
1. AS3给AS2发送BGP报文，告知x的存在，称为“AS3 x”
2. AS2向AS1发送BGP报文，告知x的存在以及，可以通过AS2到达AS3，称为“AS2 AS3 x”

事实上，发送报文的是路由器。在BGP中，每对路由器通过179端口的半永久TCP连接彼此交换路由选择信息，形成BGP连接。跨越AS的称为eBGP，否则称为iBGP。再回顾上述动作报文传递路径变成：3a=>2c=>all in AS2=>1c=>all in AS1

#### 确定最好的路由

当路由器通过BGP连接通告前缀x时，会在前缀中包括一些其他的BGP属性。前缀x与其他属性统称路由（？这统称素质也太差了）。比较重要的属性如下：
1. AS-PATH：已经通过的AS列表，每次通过一个AS时，会收录其ASN。该属性还可以用来检测通告环路（特别是列表里有它自己的ASN时）
2. NEXT-HOP：是AS-PATH中起始的路由器接口的IP地址，例如“AS2 AS3 x”中的AS2的起始接口2a，2a不属于AS1但直接连接AS1
![](Pasted%20image%2020241227000142.png)

##### 热土豆路由选择

上图中的1b将学习到到达前缀x的两条路由。热土豆算法会计算通往NEXT-HOP开销最低的路径。在图中为上路2a，开销为2。计算出所需路径后，路由器1b会查询自己的转发表（可能是OSPF计算的），并且找出通往2a的路径上的接口I，然后将(x, I)加入BGP转发表。

需要注意的是，在热土豆中，AS间和AS内部算法都被使用到了：
![](4921476e2505921b5a56d5f78cfc9d81.png)

热土豆算法的思想：对于路由器1b，应该尽可能高效的将分组送出AS，至于后续开销则与自己无关。

##### 路由器选择算法

实践中，BGP使用的算法更加复杂。假设有数条可以到达前缀x的路径，则BGP会按顺序调用以下规则直到剩下一条最优路径：
1. 路由被赋予“本地偏好”属性，属性值完全有AS管理员决定。具有最高本地偏好值的路由都将被选择
2. 选择具有最短AS-PATH的路由（计算AS的跳数）
3. 使用热土豆算法（选择最靠近NEXT-HOP的路径）
4. 如果依然有数条路径，路由器会使用BGP标识符作最终抉择

应用该完善算法，将不再那么自私

#### IP任播

BGP除了被用作AS间路由选择协议，还被用于实现IP任播服务（与DNS相关）

考虑以下情况：
1. 在分散的不同地理位置中，替换不同服务器上的同一内容（例如CDN进行服务器部分文件的更新）
2. 引导用户从最近的服务器进行访问

由此出现如下需求：DNS系统在全世界的DNS服务器上复制DNS记录，用户需要访问复制内容时，引导用户去找最近的服务器。这一需求可以通过BGP实现

![](9297761285ca648b70a3877bbc8c3579.png)
1. 在IP任播配置阶段，CDN为每台服务器配置同一IP地址，并且让每台服务器都通过BGP通告来告知路由器。
2. 当某一台BGP路由器收到该IP地址的多个路由通告时，会处理成“同一物理位置的不同路径”（事实上是不同物理位置）。那么当路由器配置路由选择表时，将使用本地设置好的算法计算最好的路径。
3. 当完成通告后，CDN会分发主要内容。
4. 客户发送请求时，CDN会返回共同IP地址，客户对IP地址发送请求，此时BGP路由器会向最近的服务器转发该请求

讲了这么多，但是CDN实践中一般不选择IP任播。BGP的变化会导致相同的TCP连接的不同分组到达Web服务器的不同实例。但DNS系统用IP任播将DNS请求只想最近的根DNS服务器很常见。

#### 路由选择策略

当某路由器选择到达目的地的一条路由时，AS路由选择策略能够越过所有规则。刚提到过的“本地偏好”属性就是由策略决定的

![](f70f104f7f67591b199ac5ae5e2fa509.png)
上述是6个互联的AS，WXY接入ISP、ABC来自网络提供商。假设ABC之间彼此发送流量且为客户网络提供全部的BGP信息。那么该网络有以下信息：
1. 接入ISP网络的流量的目的地肯定是该网络、离开ISP网络的流量肯定来源于该网络。WY显然是接入ISP，X是一个多宿接入ISP。
2. X需要避免转发BC之间的流量，这通过控制BGP路由的通告方式来实现。X告诉BC：我不能通向其他目的地，只能作为接入ISP（即使有XCY等路径）。因此B不会借助X发送目的地为Y的流量。
3. 假定B已经知道了存在路径AW，则该路径会被安装到路由信息库中。B会希望向X通告路径BAW的存在，但对于C，这一信息通告与否取决于如下经验法则：任何穿越某ISP主干网络（ABC）的流量的源/目的必须位于该ISP的某个客户网络中（WXY），不然这些流量经过ISP网络属于白嫖。ISP双方依据对等协定进行协商（对外保密），来辅助路径通告。

### 网络的拼装

在因特网中接入自己的服务器与网络：
1. 与本地ISP签订合同，让网关路由器与ISP内的一台路由器连接
2. 得到ISP分配的IP地址范围（同时也获得了前缀x），并在该范围内为设备（包括Web服务器、DNS服务器、网关路由器等）分配IP地址
3. 与因特网注册机构签订合同获得域名，并提供本地DNS服务器的IP地址以在根DNS服务器中或者一个表项
4. 在本地DNS服务器中映射Web服务器等设备的IP地址
5. 本地ISP通过BGP报文告诉其他ISP你的前缀x，从而数据报可以被正确转发进入自己的网络

### SDN控制平面

上一章讲过“泛化转发和SDN”，现在接着讲SDN。（使用分组交换机来涵盖网络层和链路层）

![](d7ae120b6036d9530b7bca83f7fb7085%201.png)
简单回顾一下SDN：
1. 基于流的转发：SDN所控制的转发工作，可以基于运输层、网络层、链路层首部中任意数量的首部字段值。例如上章OpenFlow1.0中基于11个不同的首部字段值进行转发。分组转发规则被规定在分组交换机的流表中，而SDN控制平面的工作就是计算配置所有分组交换机的流表项
2. 数据平面与控制平面分离：数据平面主要有分组交换机，根据流表执行“匹配加操作”的规则；控制平面由服务器以及管理流表的软件组成
3. 网络控制的功能：位于数据平面分组交换机外部，主要有SDN控制器和若干网络控制的应用程序组成。控制器会维护准确的网络状态信息，并将信息以及定义的一些控制方法提供给应用程序
4. 可编程的网络：运行在控制平面中的网络控制应用程序，该网络是可编程的。这些应用程序使用SDN控制器提供的API来定义和控制设备的数据平面。

对于上图结构间的实现、流通和交互如下。

#### SDN控制器与网络控制应用程序

这是SDN控制平面的两个主要部分。

![](eab9238bfc8081c1948ca96049b6eb81.png)
以自底向上的角度考虑控制器的层次：
1. 通信层：控制器与受控网络设备之间的通信。控制器通过协议和设备交换信息从而控制设备；设备需要向控制器传递本地观察到的事件，来向SDN控制网络提供最新视图。通信功能在“南向API接口”实现
2. 网络范围状态管理层：SDN控制平面做出的最终控制决定是需要有关网络的设备的最新状态信息的，因此控制器需要维护这些信息
3. 对于网络控制应用程序层的接口：控制器通过“北向API接口”与应用程序交互，这一API使得应用程序可以在状态管理层中进行读写。状态改变事件发生时，应用程序发出通告

实践中，SDN的服务与数据通常是通过分布式服务器集合实现的

#### OpenFlow协议

OpenFlow协议运行在SDN控制器和SDN控制的设备之间。OpenFlow协议运行在TCP之上，端口为6653。  
从控制器流向分组交换机的重要报文如下：
1. 配置：允许控制器读写自己的配置参数
2. 修改状态：允许控制器增删改流表中的表项、设置端口特性
3. 读状态：允许从流表和端口收集数据和计数器值
4. 发送分组：允许控制器从分组交换机的特定端口发出特定报文
从分组交换机流向控制器的重要报文如下：
1. 流删除：通知控制器已经删除了一个流表项
2. 端口状态：通知端口状态的变化
3. 分组入：对于到达端口但不能与任何流表项匹配的分组，交给控制器处理（匹配的也可以交给控制器处理）。该报文主要用于发送分组

#### 数据平面与控制平面的交互